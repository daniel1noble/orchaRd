% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mod_results.R
\name{mod_results}
\alias{mod_results}
\title{mod_results}
\usage{
mod_results(
  model,
  mod = "1",
  group,
  data,
  N = NULL,
  weights = "prop",
  by = NULL,
  at = NULL,
  subset = FALSE,
  upper = TRUE,
  ...
)
}
\arguments{
\item{model}{\code{rma.mv} model object}

\item{mod}{Moderator variable of interest that one wants marginal means for. Defaults to the intercept, i.e. \code{"1"}.}

\item{group}{The grouping variable that one wishes to plot beside total effect sizes, k. This could be study, species, or any grouping variable one wishes to present sample sizes for.}

\item{data}{The data frame used to fit the \code{rma.mv} model object.}

\item{N}{The name of the column in the data specifying the sample size, N. Defaults to \code{NULL}, so that precision is plotted instead of sample size.}

\item{weights}{How to marginalize categorical variables. The default is \code{weights = "prop"}, which weights moderator level means based on their proportional representation in the data. For example, if "sex" is a moderator, and males have a larger sample size than females, then this will produce a weighted average, where males are weighted more towards the mean than females. This may not always be ideal. In the case of sex, for example, males and females are roughly equally prevalent in a population. As such, you can give the moderator levels equal weight using \code{weights = "equal"}.}

\item{by}{Character vector indicating the name that predictions should be conditioned on for the levels of the moderator.}

\item{at}{List of levels one wishes to predict at for the corresponding variables in \code{by}. Used when one wants marginalised means. This argument can also be used to suppress levels of the moderator when argument \code{subset = TRUE}. Provide a list as follows: \code{list(mod = c("level1", "level2"))}.}

\item{subset}{Used when one wishes to only plot a subset of levels within the main moderator of interest defined by \code{mod}. Default is \code{FALSE}, but use \code{TRUE} if you wish to subset levels of a moderator plotted (defined by \code{mod}) for plotting. Levels one wishes to plot are specified as a list, with the level names as a character string in the \code{at} argument. For subsetting to work, the \code{at} argument also needs to be specified so that the \code{mod_results} function knows what levels one wishes to plot.}

\item{upper}{Logical, defaults to \code{TRUE}, indicating that the first letter of the character string for the moderator variable should be capitalized.}

\item{...}{Additional arguments passed to \code{emmeans::emmeans()}.}
}
\value{
A data frame containing all the model results including mean effect size estimate, confidence and prediction intervals
}
\description{
Using a \pkg{metafor} model object of class \code{rma} or \code{rma.mv}, this function creates a table of model results containing the mean effect size estimates for all levels of a given categorical moderator, and their corresponding confidence and prediction intervals. The function is capable of calculating marginal means from meta-regression models, including those with multiple moderator variables of mixed types (i.e. continuous and categorical variables).
}
\examples{
\dontrun{
# Simple eklof data
data(eklof)
eklof<-metafor::escalc(measure="ROM", n1i=N_control, sd1i=SD_control,
m1i=mean_control, n2i=N_treatment, sd2i=SD_treatment, m2i=mean_treatment,
data=eklof)
# Add the unit level predictor
eklof$Datapoint<-as.factor(seq(1, dim(eklof)[1], 1))
# fit a MLMR - accouting for some non-independence
eklof_MR<-metafor::rma.mv(yi=yi, V=vi, mods=~ Grazer.type, random=list(~1|ExptID,
~1|Datapoint), data=eklof)
results <- mod_results(eklof_MR, mod = "Grazer.type", group = "ExptID", data=eklof)

# Fish example demonstrating marginalised means
data(fish)
warm_dat <- fish
model <- metafor::rma.mv(yi = lnrr, V = lnrr_vi,
random = list(~1 | group_ID, ~1 | es_ID),
mods = ~ experimental_design + trait.type + deg_dif + treat_end_days,
method = "REML", test = "t", data = warm_dat,
control=list(optimizer="optim", optmethod="Nelder-Mead"))
  overall <- mod_results(model, group = "group_ID", data = warm_dat)
across_trait <- mod_results(model, group = "group_ID", mod = "trait.type", data = warm_dat)
across_trait_by_degree_diff <- mod_results(model, group = "group_ID",
mod = "trait.type", at = list(deg_dif = c(5, 10, 15)), by = "deg_dif", data = warm_dat)
across_trait_by_degree_diff_at_treat_end_days10 <- mod_results(model, group = "group_ID",
mod = "trait.type", at = list(deg_dif = c(5, 10, 15), treat_end_days = 10),
by = "deg_dif",data = warm_dat)
across_trait_by_degree_diff_at_treat_end_days10And50 <- mod_results(model, group = "group_ID",
mod = "trait.type", at = list(deg_dif = c(5, 10, 15),
 treat_end_days = c(10, 50)), by = "deg_dif", data = warm_dat)
across_trait_by_treat_end_days10And50 <- mod_results(model, group = "group_ID",
mod = "trait.type", at = list(deg_dif = c(5, 10, 15), treat_end_days = c(10, 50)),
by = "treat_end_days", data = warm_dat)
across_trait_by_treat_end_days10And50_ordinaryMM <- mod_results(model, group = "group_ID",
mod = "trait.type", at = list(deg_dif = c(5, 10, 15), treat_end_days = c(10, 50)),
by = "treat_end_days", weights = "prop", data = warm_dat)

# Fish data example with a heteroscedastic error
model_het <- metafor::rma.mv(yi = lnrr, V = lnrr_vi, random = list(~1 | group_ID, ~1 + trait.type| es_ID), mods = ~ trait.type + deg_dif, method = "REML", test = "t", rho = 0, struc = "HCS", data = warm_dat, control=list(optimizer="optim", optmethod="Nelder-Mead"))
HetModel <- mod_results(model_het, group = "group_ID", mod = "trait.type", at = list(deg_dif = c(5, 10, 15)), by = "deg_dif", weights = "prop", data = warm_dat)
orchard_plot(HetModel, xlab = "lnRR", data = warm_dat)
}
}
\author{
Shinichi Nakagawa - s.nakagawa@unsw.edu.au

Daniel Noble - daniel.noble@anu.edu.au
}
